<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dragon Flight Adventure</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/roughjs@4.5.2/bundled/rough.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
            font-family: Arial, sans-serif;
        }
        #game-container {
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 600 },
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const game = new Phaser.Game(config);

        let dragon;
        let dragonBody;
        let leftWing;
        let rightWing;
        let obstacles;
        let collectibles;
        let cursors;
        let flapKey;
        let duckKey;
        let pauseKey;
        let isPaused = false;
        let health = 5;
        let score = 0;
        let level = 1;
        let healthText;
        let scoreText;
        let levelText;
        let gameOver = false;
        let obstacleTimer;
        let collectibleTimer;
        let speed = 200;
        let roughCanvas;
        let rc;

        // Helper function to create a canvas with Rough.js drawing
        function createRoughCanvas(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            return {
                canvas: canvas,
                rc: rough.canvas(canvas)
            };
        }

        // Helper to convert hex color to RGB string
        function hexToRgb(hex) {
            const r = (hex >> 16) & 255;
            const g = (hex >> 8) & 255;
            const b = hex & 255;
            return `rgb(${r}, ${g}, ${b})`;
        }

        function preload() {
            // We'll create the dragon using Rough.js in the create function
        }

        function create() {
            // Create dragon container
            dragon = this.add.container(150, 300);

            // Create dragon body with Rough.js (hand-drawn style)
            const bodyCanvas = createRoughCanvas(150, 80);
            const bodyRc = bodyCanvas.rc;

            // Main body - sketchy ellipse
            bodyRc.ellipse(75, 40, 50, 35, {
                fill: hexToRgb(0x2d8a4d),
                fillStyle: 'solid',
                roughness: 1.5,
                strokeWidth: 2,
                stroke: hexToRgb(0x1a5c2e)
            });

            // Belly highlight
            bodyRc.ellipse(75, 45, 35, 20, {
                fill: hexToRgb(0x90EE90),
                fillStyle: 'solid',
                roughness: 1.5,
                strokeWidth: 1,
                stroke: hexToRgb(0x70d070)
            });

            // Head
            bodyRc.ellipse(105, 32, 35, 30, {
                fill: hexToRgb(0x2d8a4d),
                fillStyle: 'solid',
                roughness: 1.5,
                strokeWidth: 2,
                stroke: hexToRgb(0x1a5c2e)
            });

            // Snout
            bodyRc.ellipse(120, 35, 20, 15, {
                fill: hexToRgb(0x90EE90),
                fillStyle: 'solid',
                roughness: 1.5,
                strokeWidth: 2,
                stroke: hexToRgb(0x70d070)
            });

            // Nostrils
            bodyRc.circle(125, 32, 3, {
                fill: hexToRgb(0x1a5c2e),
                fillStyle: 'solid',
                roughness: 1.2
            });
            bodyRc.circle(125, 38, 3, {
                fill: hexToRgb(0x1a5c2e),
                fillStyle: 'solid',
                roughness: 1.2
            });

            // Eye
            bodyRc.circle(110, 28, 6, {
                fill: 'rgb(255, 255, 255)',
                fillStyle: 'solid',
                roughness: 1.0,
                strokeWidth: 2,
                stroke: 'rgb(0, 0, 0)'
            });
            bodyRc.circle(112, 28, 3, {
                fill: 'rgb(0, 0, 0)',
                fillStyle: 'solid',
                roughness: 0.8
            });

            // Eye shine
            bodyRc.circle(113, 27, 1.5, {
                fill: 'rgb(255, 255, 255)',
                fillStyle: 'solid',
                roughness: 0.5
            });

            // Horns
            bodyRc.polygon([[103, 20], [100, 12], [97, 20]], {
                fill: hexToRgb(0xffd700),
                fillStyle: 'solid',
                roughness: 1.5,
                strokeWidth: 2,
                stroke: hexToRgb(0xdaa520)
            });
            bodyRc.polygon([[110, 18], [108, 10], [106, 18]], {
                fill: hexToRgb(0xffd700),
                fillStyle: 'solid',
                roughness: 1.5,
                strokeWidth: 2,
                stroke: hexToRgb(0xdaa520)
            });

            // Spikes along back
            for (let i = 0; i < 4; i++) {
                const x = 85 - i * 8;
                bodyRc.polygon([[x, 25], [x-3, 18], [x-6, 25]], {
                    fill: hexToRgb(0xffd700),
                    fillStyle: 'solid',
                    roughness: 1.5,
                    strokeWidth: 1.5,
                    stroke: hexToRgb(0xdaa520)
                });
            }

            // Tail
            bodyRc.ellipse(50, 40, 25, 15, {
                fill: hexToRgb(0x2d8a4d),
                fillStyle: 'solid',
                roughness: 1.5,
                strokeWidth: 2,
                stroke: hexToRgb(0x1a5c2e)
            });
            bodyRc.ellipse(35, 37, 20, 12, {
                fill: hexToRgb(0x2d8a4d),
                fillStyle: 'solid',
                roughness: 1.5,
                strokeWidth: 2,
                stroke: hexToRgb(0x1a5c2e)
            });
            bodyRc.polygon([[30, 37], [20, 32], [20, 42]], {
                fill: hexToRgb(0x2d8a4d),
                fillStyle: 'solid',
                roughness: 1.5,
                strokeWidth: 2,
                stroke: hexToRgb(0x1a5c2e)
            });

            // Tail tip decoration
            bodyRc.polygon([[23, 32], [17, 30], [17, 34]], {
                fill: hexToRgb(0xff4444),
                fillStyle: 'solid',
                roughness: 1.5,
                strokeWidth: 1.5,
                stroke: hexToRgb(0xcc0000)
            });
            bodyRc.polygon([[23, 42], [17, 40], [17, 44]], {
                fill: hexToRgb(0xff4444),
                fillStyle: 'solid',
                roughness: 1.5,
                strokeWidth: 1.5,
                stroke: hexToRgb(0xcc0000)
            });

            // Create Phaser image from canvas
            this.textures.addCanvas('dragonBody', bodyCanvas.canvas);
            dragonBody = this.add.image(0, 0, 'dragonBody');
            dragonBody.setOrigin(0.5, 0.5);

            // Left wing with Rough.js
            const leftWingCanvas = createRoughCanvas(60, 50);
            const leftWingRc = leftWingCanvas.rc;

            // Wing shape
            leftWingRc.polygon([
                [15, 15],
                [0, -10],
                [-20, -20],
                [-30, -15],
                [-25, 0],
                [-10, 10]
            ], {
                fill: hexToRgb(0x228b44),
                fillStyle: 'solid',
                roughness: 2.0,
                strokeWidth: 2,
                stroke: hexToRgb(0x1a5c2e),
                fillWeight: 3
            });

            // Wing membrane lines
            leftWingRc.line(10, 10, -5, -15, {
                stroke: hexToRgb(0x1a5c2e),
                strokeWidth: 2,
                roughness: 2.0
            });
            leftWingRc.line(0, 7, -15, -17, {
                stroke: hexToRgb(0x1a5c2e),
                strokeWidth: 2,
                roughness: 2.0
            });

            this.textures.addCanvas('leftWing', leftWingCanvas.canvas);
            leftWing = this.add.image(0, 0, 'leftWing');
            leftWing.setOrigin(0.5, 0.5);
            leftWing.setAlpha(0.9);
            leftWing.x = -5;
            leftWing.y = -5;

            // Right wing with Rough.js
            const rightWingCanvas = createRoughCanvas(60, 50);
            const rightWingRc = rightWingCanvas.rc;

            // Wing shape
            rightWingRc.polygon([
                [15, 35],
                [0, 60],
                [-20, 70],
                [-30, 65],
                [-25, 50],
                [-10, 40]
            ], {
                fill: hexToRgb(0x228b44),
                fillStyle: 'solid',
                roughness: 2.0,
                strokeWidth: 2,
                stroke: hexToRgb(0x1a5c2e),
                fillWeight: 3
            });

            // Wing membrane lines
            rightWingRc.line(10, 40, -5, 65, {
                stroke: hexToRgb(0x1a5c2e),
                strokeWidth: 2,
                roughness: 2.0
            });
            rightWingRc.line(0, 43, -15, 67, {
                stroke: hexToRgb(0x1a5c2e),
                strokeWidth: 2,
                roughness: 2.0
            });

            this.textures.addCanvas('rightWing', rightWingCanvas.canvas);
            rightWing = this.add.image(0, 0, 'rightWing');
            rightWing.setOrigin(0.5, 0.5);
            rightWing.setAlpha(0.9);
            rightWing.x = -5;
            rightWing.y = 5;

            // Add all parts to container
            dragon.add([leftWing, rightWing, dragonBody]);

            // Add physics to dragon container
            this.physics.add.existing(dragon);
            dragon.body.setSize(80, 60);
            dragon.body.setOffset(-40, -30);
            dragon.body.setCollideWorldBounds(true);
            dragon.body.setBounce(0.2);

            // Create groups for obstacles and collectibles
            obstacles = this.physics.add.group();
            collectibles = this.physics.add.group();

            // Input
            cursors = this.input.keyboard.createCursorKeys();
            flapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
            duckKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.DOWN);
            pauseKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.P);

            // UI Text
            healthText = this.add.text(16, 16, 'Health: ❤️❤️❤️❤️❤️', {
                fontSize: '24px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 4
            });

            scoreText = this.add.text(16, 50, 'Score: 0', {
                fontSize: '24px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 4
            });

            levelText = this.add.text(16, 84, 'Level: 1', {
                fontSize: '24px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 4
            });

            const pauseText = this.add.text(750, 16, 'P = Pause', {
                fontSize: '20px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 3
            });
            pauseText.setOrigin(1, 0);

            // Spawn obstacles and collectibles
            obstacleTimer = this.time.addEvent({
                delay: 2000,
                callback: spawnObstacle,
                callbackScope: this,
                loop: true
            });

            collectibleTimer = this.time.addEvent({
                delay: 3500,
                callback: spawnCollectible,
                callbackScope: this,
                loop: true
            });

            // Collisions
            this.physics.add.overlap(dragon, obstacles, hitObstacle, null, this);
            this.physics.add.overlap(dragon, collectibles, collectItem, null, this);

            // Instructions
            const instructions = this.add.text(400, 300,
                'SPACE or UP = Flap Wings (Go Higher)\nDOWN = Duck (Go Lower)\n\nAvoid obstacles! Collect stars!\n\nPress SPACE to start!',
                {
                    fontSize: '20px',
                    fill: '#fff',
                    stroke: '#000',
                    strokeThickness: 4,
                    align: 'center'
                }
            );
            instructions.setOrigin(0.5);

            this.time.delayedCall(3000, () => {
                instructions.destroy();
            });
        }

        function update() {
            if (gameOver) {
                return;
            }

            // Toggle pause
            if (Phaser.Input.Keyboard.JustDown(pauseKey)) {
                isPaused = !isPaused;
                if (isPaused) {
                    this.physics.pause();
                    obstacleTimer.paused = true;
                    collectibleTimer.paused = true;

                    const pauseMsg = this.add.text(400, 300, 'PAUSED\nPress P to resume', {
                        fontSize: '48px',
                        fill: '#fff',
                        stroke: '#000',
                        strokeThickness: 6,
                        align: 'center'
                    });
                    pauseMsg.setOrigin(0.5);
                    pauseMsg.setName('pauseMessage');
                } else {
                    this.physics.resume();
                    obstacleTimer.paused = false;
                    collectibleTimer.paused = false;

                    const pauseMsg = this.children.getByName('pauseMessage');
                    if (pauseMsg) pauseMsg.destroy();
                }
            }

            if (isPaused) {
                return;
            }

            // Flap wings (go up)
            if (Phaser.Input.Keyboard.JustDown(flapKey) || Phaser.Input.Keyboard.JustDown(cursors.up)) {
                dragon.body.setVelocityY(-300);

                // Wing flap animation
                this.tweens.add({
                    targets: leftWing,
                    y: -25,
                    duration: 100,
                    yoyo: true
                });
                this.tweens.add({
                    targets: rightWing,
                    y: 25,
                    duration: 100,
                    yoyo: true
                });

                // Body tilt
                this.tweens.add({
                    targets: dragon,
                    angle: -15,
                    duration: 100,
                    yoyo: true
                });
            }

            // Duck (go down faster)
            if (cursors.down.isDown || duckKey.isDown) {
                dragon.body.setVelocityY(400);

                // Fold wings animation
                if (!leftWing.getData('folded')) {
                    this.tweens.add({
                        targets: leftWing,
                        scaleY: 0.5,
                        duration: 150
                    });
                    this.tweens.add({
                        targets: rightWing,
                        scaleY: 0.5,
                        duration: 150
                    });
                    leftWing.setData('folded', true);
                }

                // Body tilt down
                dragon.angle = 15;
            } else {
                // Unfold wings
                if (leftWing.getData('folded')) {
                    this.tweens.add({
                        targets: [leftWing, rightWing],
                        scaleY: 1,
                        duration: 150
                    });
                    leftWing.setData('folded', false);
                }

                // Reset body angle
                if (dragon.angle > 0) {
                    dragon.angle = Math.max(0, dragon.angle - 1);
                }
            }

            // Idle wing movement
            if (!Phaser.Input.Keyboard.JustDown(flapKey) && !cursors.down.isDown) {
                const time = this.time.now;
                leftWing.y = -5 + Math.sin(time / 200) * 3;
                rightWing.y = 5 - Math.sin(time / 200) * 3;
            }

            // Move obstacles and collectibles
            obstacles.children.entries.forEach(obstacle => {
                obstacle.x -= speed * 0.016;
                if (obstacle.x < -50) {
                    obstacle.destroy();
                    score += 10;
                    updateScore();
                }
            });

            collectibles.children.entries.forEach(collectible => {
                collectible.x -= speed * 0.016;
                if (collectible.x < -50) {
                    collectible.destroy();
                }
            });

            // Level progression
            if (score > 0 && score % 100 === 0 && score > (level - 1) * 100) {
                levelUp(this);
            }
        }

        function spawnObstacle() {
            if (gameOver) return;

            const type = Phaser.Math.Between(0, 1);
            const yPos = Phaser.Math.Between(100, 500);

            const obstacleCanvas = createRoughCanvas(50, 100);
            const obstacleRc = obstacleCanvas.rc;

            if (type === 0) {
                // Rock obstacle with sketchy detail
                obstacleRc.rectangle(5, 20, 40, 80, {
                    fill: hexToRgb(0x8B4513),
                    fillStyle: 'solid',
                    roughness: 2.5,
                    strokeWidth: 2,
                    stroke: hexToRgb(0x654321),
                    fillWeight: 2
                });

                obstacleRc.polygon([[5, 20], [25, -10], [45, 20]], {
                    fill: hexToRgb(0x654321),
                    fillStyle: 'hachure',
                    roughness: 2.5,
                    strokeWidth: 2,
                    stroke: hexToRgb(0x5a3a1a),
                    hachureAngle: 60
                });

                // Texture spots
                obstacleRc.circle(15, 40, 5, {
                    fill: hexToRgb(0x5a3a1a),
                    fillStyle: 'solid',
                    roughness: 2.0
                });
                obstacleRc.circle(30, 70, 6, {
                    fill: hexToRgb(0x5a3a1a),
                    fillStyle: 'solid',
                    roughness: 2.0
                });
            } else {
                // Stalactite/stalagmite with sketchy texture
                obstacleRc.polygon([[5, 20], [25, 80], [45, 20]], {
                    fill: hexToRgb(0x696969),
                    fillStyle: 'solid',
                    roughness: 2.5,
                    strokeWidth: 2.5,
                    stroke: hexToRgb(0x505050),
                    fillWeight: 2
                });

                obstacleRc.polygon([[13, 30], [25, 70], [37, 30]], {
                    fill: hexToRgb(0x505050),
                    fillStyle: 'hachure',
                    roughness: 2.0,
                    hachureAngle: -60
                });
            }

            const textureName = `obstacle_${Date.now()}_${Math.random()}`;
            this.textures.addCanvas(textureName, obstacleCanvas.canvas);
            const obstacle = this.add.image(850, yPos, textureName);
            obstacle.setOrigin(0.5, 0.5);

            this.physics.add.existing(obstacle);
            obstacle.body.setSize(40, 60);
            obstacle.body.setAllowGravity(false);
            obstacle.body.setImmovable(true);
            obstacle.body.moves = false;

            obstacles.add(obstacle);
        }

        function spawnCollectible() {
            if (gameOver) return;

            const yPos = Phaser.Math.Between(100, 500);

            const starCanvas = createRoughCanvas(50, 50);
            const starRc = starCanvas.rc;

            // Draw a sketchy star
            const starPoints = [];
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                const x = 25 + Math.cos(angle) * 15;
                const y = 25 + Math.sin(angle) * 15;
                starPoints.push([x, y]);
            }

            starRc.polygon(starPoints, {
                fill: hexToRgb(0xFFD700),
                fillStyle: 'solid',
                roughness: 1.8,
                strokeWidth: 2.5,
                stroke: hexToRgb(0xdaa520),
                fillWeight: 2
            });

            // Add sketchy glow effect
            starRc.circle(25, 25, 18, {
                stroke: hexToRgb(0xFFFF00),
                strokeWidth: 3,
                roughness: 1.5,
                fill: 'none'
            });

            const textureName = `star_${Date.now()}_${Math.random()}`;
            this.textures.addCanvas(textureName, starCanvas.canvas);
            const collectible = this.add.image(850, yPos, textureName);
            collectible.setOrigin(0.5, 0.5);

            this.physics.add.existing(collectible);
            collectible.body.setCircle(15);
            collectible.body.setAllowGravity(false);
            collectible.body.moves = false;

            collectibles.add(collectible);

            // Sparkle animation
            this.tweens.add({
                targets: collectible,
                scaleX: 1.3,
                scaleY: 1.3,
                duration: 500,
                yoyo: true,
                repeat: -1
            });
        }

        function hitObstacle(dragon, obstacle) {
            obstacle.destroy();
            health--;
            updateHealth();

            // Flash red
            this.cameras.main.flash(200, 255, 0, 0);

            if (health <= 0) {
                endGame(this);
            }
        }

        function collectItem(dragon, collectible) {
            collectible.destroy();
            health = Math.min(5, health + 1);
            score += 20;
            updateHealth();
            updateScore();

            // Flash green
            this.cameras.main.flash(200, 0, 255, 0);
        }

        function updateHealth() {
            const hearts = '❤️'.repeat(health);
            healthText.setText('Health: ' + hearts);
        }

        function updateScore() {
            scoreText.setText('Score: ' + score);
        }

        function levelUp(scene) {
            level++;
            levelText.setText('Level: ' + level);
            speed += 30;

            // Show level up message
            const levelUpText = scene.add.text(400, 300, 'LEVEL UP!', {
                fontSize: '48px',
                fill: '#FFD700',
                stroke: '#000',
                strokeThickness: 6
            });
            levelUpText.setOrigin(0.5);

            scene.tweens.add({
                targets: levelUpText,
                scaleX: 1.5,
                scaleY: 1.5,
                alpha: 0,
                duration: 1500,
                onComplete: () => levelUpText.destroy()
            });

            // Spawn obstacles faster
            obstacleTimer.delay = Math.max(800, 2000 - (level * 200));
        }

        function endGame(scene) {
            gameOver = true;

            scene.physics.pause();

            // Change dragon to defeated colors - red tint
            dragonBody.setTint(0x8B0000);
            leftWing.setTint(0x8B0000);
            rightWing.setTint(0x8B0000);

            const gameOverText = scene.add.text(400, 250, 'GAME OVER!', {
                fontSize: '64px',
                fill: '#ff0000',
                stroke: '#000',
                strokeThickness: 8
            });
            gameOverText.setOrigin(0.5);

            const finalScore = scene.add.text(400, 330, `Final Score: ${score}`, {
                fontSize: '32px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 4
            });
            finalScore.setOrigin(0.5);

            const restartText = scene.add.text(400, 400, 'Refresh page to play again!', {
                fontSize: '24px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 4
            });
            restartText.setOrigin(0.5);
        }
    </script>
</body>
</html>
