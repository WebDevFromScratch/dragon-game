<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dragon Flight Adventure</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/roughjs@4.5.2/bundled/rough.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
            font-family: Arial, sans-serif;
        }
        #game-container {
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'game-container',
            backgroundColor: '#0a0a0a', // Very dark background (will be behind our scrolling background)
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 400 },
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const game = new Phaser.Game(config);

        let dragon;
        let obstacles;
        let collectibles;
        let fireBoosts;
        let caveWalls;
        let topWallSegments = [];
        let bottomWallSegments = [];
        let cursors;
        let flapKey;
        let duckKey;
        let pauseKey;
        let debugKey;
        let fireKey;
        let debugMode = false;
        let isPaused = false;
        let health = 5;
        let score = 0;
        let level = 1;
        let fireBreaths = 0;
        let maxFireBreaths = 3;
        let healthText;
        let scoreText;
        let levelText;
        let fireBreathText;
        let gameOver = false;
        let gameStarted = false;
        let obstacleTimer;
        let collectibleTimer;
        let fireBoostTimer;
        let speed = 200;
        let roughCanvas;
        let rc;
        let caveWallHitCooldown = false;
        let instructions;
        let activeFireBreath = null;
        let backgroundLayer1;
        let backgroundLayer2;

        // Helper function to create a canvas with Rough.js drawing
        function createRoughCanvas(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            return {
                canvas: canvas,
                rc: rough.canvas(canvas)
            };
        }

        // Helper to convert hex color to RGB string
        function hexToRgb(hex) {
            const r = (hex >> 16) & 255;
            const g = (hex >> 8) & 255;
            const b = hex & 255;
            return `rgb(${r}, ${g}, ${b})`;
        }

        function preload() {
            // Load background image for parallax scrolling
            // If file doesn't exist yet, we'll create a simple gradient background
            this.load.image('caveBackground', 'cave_background.png');
            this.load.on('loaderror', (file) => {
                if (file.key === 'caveBackground') {
                    console.log('Background image not found, will use gradient');
                }
            });

            // Load dragon sprite sheet (version 3)
            // 2 columns x 2 rows = 4 frames
            // Each frame is 768x512px
            this.load.spritesheet('dragon', 'dragon_sprites_3.png', {
                frameWidth: 768,
                frameHeight: 512,
                startFrame: 0,
                endFrame: 3
            });

            // Load fire breath sprite sheet
            // 2 columns x 2 rows = 4 frames
            this.load.spritesheet('fireBreath', 'fire_breath.png', {
                frameWidth: 663,
                frameHeight: 444,
                startFrame: 0,
                endFrame: 3
            });
        }

        function createWallTexture(isTop) {
            const wallCanvas = createRoughCanvas(800, 70);
            const wallRc = wallCanvas.rc;

            // Draw irregular rocky cave wall
            const wallPoints = [];
            for (let x = 0; x <= 800; x += 40) {
                const y = isTop ? (50 + Math.random() * 20) : (20 + Math.random() * 20);
                wallPoints.push([x, y]);
            }

            if (isTop) {
                wallPoints.unshift([0, 0]);
                wallPoints.push([800, 0]);
            } else {
                wallPoints.push([800, 70]);
                wallPoints.unshift([0, 70]);
            }

            wallRc.polygon(wallPoints, {
                fill: hexToRgb(0x4a4a4a),
                fillStyle: 'hachure',
                roughness: 2.5,
                strokeWidth: 3,
                stroke: hexToRgb(0x2a2a2a),
                hachureAngle: isTop ? 45 : -45,
                fillWeight: 3
            });

            // Add some rocky details
            for (let i = 0; i < 8; i++) {
                const x = i * 100 + 50;
                const y = isTop ? (40 + Math.random() * 15) : (30 + Math.random() * 15);
                wallRc.circle(x, y, 5 + Math.random() * 10, {
                    fill: hexToRgb(0x3a3a3a),
                    fillStyle: 'solid',
                    roughness: 3.0
                });
            }

            return wallCanvas.canvas;
        }

        function create() {
            // Create parallax scrolling background layers
            if (this.textures.exists('caveBackground')) {
                // Far background layer (scrolls slowest for depth effect)
                backgroundLayer1 = this.add.tileSprite(400, 300, 800, 600, 'caveBackground');
                backgroundLayer1.setAlpha(0.6); // Slightly transparent for depth
                backgroundLayer1.setDepth(-2);

                // Mid background layer (scrolls medium speed)
                backgroundLayer2 = this.add.tileSprite(400, 300, 800, 600, 'caveBackground');
                backgroundLayer2.setAlpha(0.8);
                backgroundLayer2.setDepth(-1);
            } else {
                // Fallback: Create a gradient background using canvas
                const bgCanvas = document.createElement('canvas');
                bgCanvas.width = 800;
                bgCanvas.height = 600;
                const ctx = bgCanvas.getContext('2d');

                // Create dark cave gradient
                const gradient = ctx.createLinearGradient(0, 0, 0, 600);
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(0.5, '#16213e');
                gradient.addColorStop(1, '#0f3460');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 800, 600);

                this.textures.addCanvas('gradientBg', bgCanvas);
                backgroundLayer1 = this.add.tileSprite(400, 300, 800, 600, 'gradientBg');
                backgroundLayer1.setDepth(-2);
            }

            // Create cave walls (top and bottom) for tunnel effect with scrolling
            caveWalls = this.add.group();

            // Create multiple segments for scrolling effect
            for (let i = 0; i < 3; i++) {
                // Top wall segment
                const topTextureName = `topWall_${i}`;
                this.textures.addCanvas(topTextureName, createWallTexture(true));
                const topWall = this.add.image(i * 800 + 400, 35, topTextureName);
                topWall.setOrigin(0.5, 0.5);
                this.physics.add.existing(topWall);
                topWall.body.setAllowGravity(false);
                topWall.body.setImmovable(true);
                topWall.body.setSize(800, 70);
                topWall.body.moves = false;
                topWallSegments.push(topWall);
                caveWalls.add(topWall);

                // Bottom wall segment
                const bottomTextureName = `bottomWall_${i}`;
                this.textures.addCanvas(bottomTextureName, createWallTexture(false));
                const bottomWall = this.add.image(i * 800 + 400, 565, bottomTextureName);
                bottomWall.setOrigin(0.5, 0.5);
                this.physics.add.existing(bottomWall);
                bottomWall.body.setAllowGravity(false);
                bottomWall.body.setImmovable(true);
                bottomWall.body.setSize(800, 70);
                bottomWall.body.moves = false;
                bottomWallSegments.push(bottomWall);
                caveWalls.add(bottomWall);
            }

            // Create dragon sprite with animation
            dragon = this.add.sprite(150, 300, 'dragon', 0);
            dragon.setOrigin(0.5, 0.5); // Explicitly center the sprite to minimize jumping
            dragon.setScale(0.13); // Scale from 768x512 to ~100x67px

            // Create flying animation from sprite sheet
            this.anims.create({
                key: 'fly',
                frames: this.anims.generateFrameNumbers('dragon', { start: 0, end: 3 }),
                frameRate: 10,
                repeat: -1,
                yoyo: false
            });

            // Create idle animation (slower)
            this.anims.create({
                key: 'idle',
                frames: this.anims.generateFrameNumbers('dragon', { start: 0, end: 3 }),
                frameRate: 6,
                repeat: -1,
                yoyo: false
            });

            // Start with idle animation
            dragon.play('idle');

            // Create fire breath animation
            this.anims.create({
                key: 'breatheFire',
                frames: this.anims.generateFrameNumbers('fireBreath', { start: 0, end: 3 }),
                frameRate: 12,
                repeat: -1
            });

            // Add physics to dragon sprite
            this.physics.add.existing(dragon);
            // Physics body dimensions are in original texture space (768x512)
            // Dragon's main body is roughly 520x350 in texture space
            dragon.body.setSize(520, 350);
            dragon.body.setOffset(124, 81); // Center the body on the visible dragon
            dragon.body.setBounce(0.2);

            // Create groups for obstacles and collectibles
            obstacles = this.physics.add.group();
            collectibles = this.physics.add.group();
            fireBoosts = this.physics.add.group();

            // Input
            cursors = this.input.keyboard.createCursorKeys();
            flapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
            duckKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.DOWN);
            pauseKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.P);
            debugKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);
            fireKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);

            // UI Text
            healthText = this.add.text(16, 16, 'Health: â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸', {
                fontSize: '24px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 4
            });

            scoreText = this.add.text(16, 50, 'Score: 0', {
                fontSize: '24px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 4
            });

            levelText = this.add.text(16, 84, 'Level: 1', {
                fontSize: '24px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 4
            });

            fireBreathText = this.add.text(16, 118, 'Fire: ðŸ”¥ðŸ”¥ðŸ”¥', {
                fontSize: '24px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 4
            });
            updateFireBreathDisplay();

            const pauseText = this.add.text(750, 16, 'P = Pause', {
                fontSize: '20px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 3
            });
            pauseText.setOrigin(1, 0);

            const debugText = this.add.text(750, 44, 'D = Debug', {
                fontSize: '20px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 3
            });
            debugText.setOrigin(1, 0);

            const fireText = this.add.text(750, 72, 'F = Fire Breath', {
                fontSize: '20px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 3
            });
            fireText.setOrigin(1, 0);

            // Spawn obstacles and collectibles (paused until game starts)
            obstacleTimer = this.time.addEvent({
                delay: 2500,
                callback: spawnObstacle,
                callbackScope: this,
                loop: true,
                paused: true
            });

            collectibleTimer = this.time.addEvent({
                delay: 3500,
                callback: spawnCollectible,
                callbackScope: this,
                loop: true,
                paused: true
            });

            fireBoostTimer = this.time.addEvent({
                delay: 8000,
                callback: spawnFireBoost,
                callbackScope: this,
                loop: true,
                paused: true
            });

            // Collisions
            this.physics.add.overlap(dragon, obstacles, hitObstacle, null, this);
            this.physics.add.overlap(dragon, collectibles, collectItem, null, this);
            this.physics.add.overlap(dragon, fireBoosts, collectFireBoost, null, this);
            // Use collider for cave walls to physically block the dragon from passing through
            this.physics.add.collider(dragon, caveWalls, hitCaveWall, null, this);

            // Instructions (stays until game starts)
            instructions = this.add.text(400, 300,
                'SPACE or UP = Flap Wings (Go Higher)\nDOWN = Duck (Go Lower)\nF = Breathe Fire\n\nFly through the cave!\nAvoid walls and obstacles! Collect stars and fire!\n\nPress SPACE to start!',
                {
                    fontSize: '20px',
                    fill: '#fff',
                    stroke: '#000',
                    strokeThickness: 4,
                    align: 'center'
                }
            );
            instructions.setOrigin(0.5);

            // Pause physics until game starts
            this.physics.pause();
        }

        function update() {
            // Wait for player to start the game
            if (!gameStarted && !gameOver) {
                if (Phaser.Input.Keyboard.JustDown(flapKey) || Phaser.Input.Keyboard.JustDown(cursors.up)) {
                    gameStarted = true;
                    this.physics.resume();
                    obstacleTimer.paused = false;
                    collectibleTimer.paused = false;
                    fireBoostTimer.paused = false;
                    if (instructions) {
                        instructions.destroy();
                        instructions = null;
                    }
                }
                return;
            }

            if (gameOver) {
                return;
            }

            // Toggle debug mode
            if (Phaser.Input.Keyboard.JustDown(debugKey)) {
                debugMode = !debugMode;
                this.physics.world.drawDebug = debugMode;

                // Toggle the debug graphics
                if (debugMode) {
                    this.physics.world.createDebugGraphic();
                } else {
                    if (this.physics.world.debugGraphic) {
                        this.physics.world.debugGraphic.clear();
                    }
                }
            }

            // Toggle pause
            if (Phaser.Input.Keyboard.JustDown(pauseKey)) {
                isPaused = !isPaused;
                if (isPaused) {
                    this.physics.pause();
                    obstacleTimer.paused = true;
                    collectibleTimer.paused = true;
                    fireBoostTimer.paused = true;

                    const pauseMsg = this.add.text(400, 300, 'PAUSED\nPress P to resume', {
                        fontSize: '48px',
                        fill: '#fff',
                        stroke: '#000',
                        strokeThickness: 6,
                        align: 'center'
                    });
                    pauseMsg.setOrigin(0.5);
                    pauseMsg.setName('pauseMessage');
                } else {
                    this.physics.resume();
                    obstacleTimer.paused = false;
                    collectibleTimer.paused = false;
                    fireBoostTimer.paused = false;

                    const pauseMsg = this.children.getByName('pauseMessage');
                    if (pauseMsg) pauseMsg.destroy();
                }
            }

            if (isPaused) {
                return;
            }

            // Flap wings (go up)
            if (Phaser.Input.Keyboard.JustDown(flapKey) || Phaser.Input.Keyboard.JustDown(cursors.up)) {
                dragon.body.setVelocityY(-300);

                // Switch to fast flapping animation
                if (dragon.anims.currentAnim.key !== 'fly') {
                    dragon.play('fly');
                }

                // Body tilt up
                this.tweens.add({
                    targets: dragon,
                    angle: -15,
                    duration: 100,
                    yoyo: true
                });
            }

            // Duck (go down faster)
            if (cursors.down.isDown || duckKey.isDown) {
                dragon.body.setVelocityY(400);

                // Slower animation when ducking
                if (dragon.anims.currentAnim.key !== 'idle') {
                    dragon.play('idle');
                }

                // Body tilt down
                dragon.angle = 15;
            } else {
                // Reset body angle
                if (dragon.angle > 0) {
                    dragon.angle = Math.max(0, dragon.angle - 1);
                } else if (dragon.angle < 0) {
                    dragon.angle = Math.min(0, dragon.angle + 1);
                }

                // Use idle animation when not pressing keys
                if (!Phaser.Input.Keyboard.JustDown(flapKey) && dragon.anims.currentAnim.key !== 'idle') {
                    dragon.play('idle');
                }
            }

            // Fire breathing
            if (Phaser.Input.Keyboard.JustDown(fireKey) && fireBreaths > 0 && !activeFireBreath) {
                breatheFire(this);
            }

            // Update fire breath position to follow dragon
            if (activeFireBreath) {
                activeFireBreath.x = dragon.x + 10;
                activeFireBreath.y = dragon.y;
            }

            // Scroll background layers for parallax effect
            if (backgroundLayer1) {
                backgroundLayer1.tilePositionX += speed * 0.016 * 0.3; // Scrolls at 30% speed (far background)
            }
            if (backgroundLayer2) {
                backgroundLayer2.tilePositionX += speed * 0.016 * 0.6; // Scrolls at 60% speed (mid background)
            }

            // Scroll cave walls for tunnel effect
            topWallSegments.forEach(wall => {
                wall.x -= speed * 0.016;
                // When wall goes off left side, move it to the right side
                if (wall.x < -400) {
                    wall.x += 800 * 3; // Move to end of the 3 segments
                }
            });

            bottomWallSegments.forEach(wall => {
                wall.x -= speed * 0.016;
                // When wall goes off left side, move it to the right side
                if (wall.x < -400) {
                    wall.x += 800 * 3; // Move to end of the 3 segments
                }
            });

            // Move obstacles and collectibles
            obstacles.children.entries.forEach(obstacle => {
                obstacle.x -= speed * 0.016;
                if (obstacle.x < -50) {
                    obstacle.destroy();
                    // Only award points if dragon is in valid position (accounting for hitbox)
                    // Dragon hitbox is 50px tall (Â±25 from center), walls end at 70 (top) and start at 530 (bottom)
                    const dragonTop = dragon.y - 25;
                    const dragonBottom = dragon.y + 25;
                    if (dragonTop > 70 && dragonBottom < 530) {
                        score += 10;
                        updateScore();
                    }
                }
            });

            collectibles.children.entries.forEach(collectible => {
                collectible.x -= speed * 0.016;
                if (collectible.x < -50) {
                    collectible.destroy();
                }
            });

            fireBoosts.children.entries.forEach(fireBoost => {
                fireBoost.x -= speed * 0.016;
                if (fireBoost.x < -50) {
                    fireBoost.destroy();
                }
            });

            // Level progression
            if (score > 0 && score % 100 === 0 && score > (level - 1) * 100) {
                levelUp(this);
            }
        }

        function spawnObstacle() {
            if (gameOver) return;

            const type = Phaser.Math.Between(0, 1);
            const yPos = Phaser.Math.Between(100, 500);

            const obstacleCanvas = createRoughCanvas(40, 70);
            const obstacleRc = obstacleCanvas.rc;

            if (type === 0) {
                // Rock obstacle with sketchy detail (smaller for easier gameplay)
                obstacleRc.rectangle(5, 15, 30, 55, {
                    fill: hexToRgb(0x8B4513),
                    fillStyle: 'solid',
                    roughness: 2.5,
                    strokeWidth: 2,
                    stroke: hexToRgb(0x654321),
                    fillWeight: 2
                });

                obstacleRc.polygon([[5, 15], [20, -5], [35, 15]], {
                    fill: hexToRgb(0x654321),
                    fillStyle: 'hachure',
                    roughness: 2.5,
                    strokeWidth: 2,
                    stroke: hexToRgb(0x5a3a1a),
                    hachureAngle: 60
                });

                // Texture spots
                obstacleRc.circle(12, 30, 4, {
                    fill: hexToRgb(0x5a3a1a),
                    fillStyle: 'solid',
                    roughness: 2.0
                });
                obstacleRc.circle(23, 50, 5, {
                    fill: hexToRgb(0x5a3a1a),
                    fillStyle: 'solid',
                    roughness: 2.0
                });
            } else {
                // Stalactite/stalagmite with sketchy texture (smaller)
                obstacleRc.polygon([[5, 15], [20, 60], [35, 15]], {
                    fill: hexToRgb(0x696969),
                    fillStyle: 'solid',
                    roughness: 2.5,
                    strokeWidth: 2.5,
                    stroke: hexToRgb(0x505050),
                    fillWeight: 2
                });

                obstacleRc.polygon([[10, 22], [20, 52], [30, 22]], {
                    fill: hexToRgb(0x505050),
                    fillStyle: 'hachure',
                    roughness: 2.0,
                    hachureAngle: -60
                });
            }

            const textureName = `obstacle_${Date.now()}_${Math.random()}`;
            this.textures.addCanvas(textureName, obstacleCanvas.canvas);
            const obstacle = this.add.image(850, yPos, textureName);
            obstacle.setOrigin(0.5, 0.5);

            this.physics.add.existing(obstacle);
            obstacle.body.setSize(30, 45);
            obstacle.body.setAllowGravity(false);
            obstacle.body.setImmovable(true);
            obstacle.body.moves = false;

            obstacles.add(obstacle);
        }

        function spawnCollectible() {
            if (gameOver) return;

            const yPos = Phaser.Math.Between(100, 500);

            const starCanvas = createRoughCanvas(50, 50);
            const starRc = starCanvas.rc;

            // Draw a sketchy star
            const starPoints = [];
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                const x = 25 + Math.cos(angle) * 15;
                const y = 25 + Math.sin(angle) * 15;
                starPoints.push([x, y]);
            }

            starRc.polygon(starPoints, {
                fill: hexToRgb(0xFFD700),
                fillStyle: 'solid',
                roughness: 1.8,
                strokeWidth: 2.5,
                stroke: hexToRgb(0xdaa520),
                fillWeight: 2
            });

            // Add sketchy glow effect
            starRc.circle(25, 25, 18, {
                stroke: hexToRgb(0xFFFF00),
                strokeWidth: 3,
                roughness: 1.5,
                fill: 'none'
            });

            const textureName = `star_${Date.now()}_${Math.random()}`;
            this.textures.addCanvas(textureName, starCanvas.canvas);
            const collectible = this.add.image(850, yPos, textureName);
            collectible.setOrigin(0.5, 0.5);

            this.physics.add.existing(collectible);
            collectible.body.setCircle(20); // Increased to better match visual star
            collectible.body.setAllowGravity(false);
            collectible.body.moves = false;

            collectibles.add(collectible);

            // Sparkle animation
            this.tweens.add({
                targets: collectible,
                scaleX: 1.3,
                scaleY: 1.3,
                duration: 500,
                yoyo: true,
                repeat: -1
            });
        }

        function hitObstacle(dragon, obstacle) {
            obstacle.destroy();
            health--;
            updateHealth();

            // Flash red
            this.cameras.main.flash(200, 255, 0, 0);

            if (health <= 0) {
                endGame(this);
            }
        }

        function hitCaveWall(dragon, wall) {
            // Don't destroy wall (it's permanent)
            // Use cooldown to prevent rapid repeated damage
            if (caveWallHitCooldown) return;

            caveWallHitCooldown = true;
            health--;
            updateHealth();

            // Flash red
            this.cameras.main.flash(200, 255, 0, 0);

            // Camera shake for impact
            this.cameras.main.shake(200, 0.01);

            // Reset cooldown after half a second
            this.time.delayedCall(500, () => {
                caveWallHitCooldown = false;
            });

            if (health <= 0) {
                endGame(this);
            }
        }

        function collectItem(dragon, collectible) {
            collectible.destroy();
            health = Math.min(5, health + 1);
            score += 20;
            updateHealth();
            updateScore();

            // Flash green
            this.cameras.main.flash(200, 0, 255, 0);
        }

        function spawnFireBoost() {
            if (gameOver) return;

            const yPos = Phaser.Math.Between(100, 500);

            const fireCanvas = createRoughCanvas(50, 50);
            const fireRc = fireCanvas.rc;

            // Draw a sketchy flame
            // Bottom of flame (wider)
            fireRc.polygon([[25, 45], [15, 35], [10, 25], [15, 15], [25, 5], [35, 15], [40, 25], [35, 35]], {
                fill: hexToRgb(0xFF4500),
                fillStyle: 'solid',
                roughness: 2.5,
                strokeWidth: 2.5,
                stroke: hexToRgb(0xFF8C00),
                fillWeight: 2
            });

            // Inner flame (yellow/bright)
            fireRc.polygon([[25, 35], [20, 28], [18, 20], [25, 10], [32, 20], [30, 28]], {
                fill: hexToRgb(0xFFD700),
                fillStyle: 'solid',
                roughness: 2.0,
                strokeWidth: 2,
                stroke: hexToRgb(0xFFA500),
                fillWeight: 2
            });

            // Add sketchy glow effect
            fireRc.circle(25, 25, 22, {
                stroke: hexToRgb(0xFF6347),
                strokeWidth: 2,
                roughness: 2.5,
                fill: 'none'
            });

            const textureName = `fire_${Date.now()}_${Math.random()}`;
            this.textures.addCanvas(textureName, fireCanvas.canvas);
            const fireBoost = this.add.image(850, yPos, textureName);
            fireBoost.setOrigin(0.5, 0.5);

            this.physics.add.existing(fireBoost);
            fireBoost.body.setCircle(20);
            fireBoost.body.setAllowGravity(false);
            fireBoost.body.moves = false;

            fireBoosts.add(fireBoost);

            // Flicker animation
            this.tweens.add({
                targets: fireBoost,
                alpha: 0.7,
                scaleX: 1.2,
                scaleY: 1.2,
                duration: 300,
                yoyo: true,
                repeat: -1
            });
        }

        function collectFireBoost(dragon, fireBoost) {
            fireBoost.destroy();
            fireBreaths = maxFireBreaths; // Always set to max (3)
            score += 30;
            updateFireBreathDisplay();
            updateScore();

            // Flash orange
            this.cameras.main.flash(200, 255, 165, 0);
        }

        function breatheFire(scene) {
            // Reduce fire breath count
            fireBreaths--;
            updateFireBreathDisplay();

            // Position fire breath right at dragon's front (using sprite animation)
            const fireBreath = scene.add.sprite(dragon.x + 40, dragon.y, 'fireBreath', 0);
            fireBreath.setOrigin(0, 0.5);
            fireBreath.setScale(0.15); // Scale from 663x444 to ~100x67px

            // Play fire breath animation
            fireBreath.play('breatheFire');

            // Add physics
            scene.physics.add.existing(fireBreath);
            fireBreath.body.setSize(500, 300); // Physics body in texture space
            fireBreath.body.setAllowGravity(false);
            fireBreath.body.setImmovable(true);

            activeFireBreath = fireBreath;

            // Add collision with obstacles
            scene.physics.add.overlap(fireBreath, obstacles, burnObstacle, null, scene);

            // Remove fire breath after 1.5 seconds
            scene.time.delayedCall(1500, () => {
                if (fireBreath) {
                    fireBreath.destroy();
                }
                activeFireBreath = null;
            });
        }

        function burnObstacle(fireBreath, obstacle) {
            // Destroy the obstacle
            obstacle.destroy();
            score += 5;
            updateScore();

            // Flash yellow
            this.cameras.main.flash(100, 255, 255, 0);
        }

        function updateFireBreathDisplay() {
            const fires = 'ðŸ”¥'.repeat(fireBreaths);
            const emptyFires = 'âš«'.repeat(maxFireBreaths - fireBreaths);
            fireBreathText.setText('Fire: ' + fires + emptyFires);
        }

        function updateHealth() {
            const hearts = 'â¤ï¸'.repeat(health);
            healthText.setText('Health: ' + hearts);
        }

        function updateScore() {
            scoreText.setText('Score: ' + score);
        }

        function levelUp(scene) {
            level++;
            levelText.setText('Level: ' + level);
            speed += 30;

            // Show level up message
            const levelUpText = scene.add.text(400, 300, 'LEVEL UP!', {
                fontSize: '48px',
                fill: '#FFD700',
                stroke: '#000',
                strokeThickness: 6
            });
            levelUpText.setOrigin(0.5);

            scene.tweens.add({
                targets: levelUpText,
                scaleX: 1.5,
                scaleY: 1.5,
                alpha: 0,
                duration: 1500,
                onComplete: () => levelUpText.destroy()
            });

            // Spawn obstacles faster
            obstacleTimer.delay = Math.max(800, 2000 - (level * 200));
        }

        function endGame(scene) {
            gameOver = true;

            scene.physics.pause();

            // Change dragon to defeated colors - red tint
            dragon.setTint(0x8B0000);
            dragon.stop(); // Stop animation

            const gameOverText = scene.add.text(400, 250, 'GAME OVER!', {
                fontSize: '64px',
                fill: '#ff0000',
                stroke: '#000',
                strokeThickness: 8
            });
            gameOverText.setOrigin(0.5);

            const finalScore = scene.add.text(400, 330, `Final Score: ${score}`, {
                fontSize: '32px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 4
            });
            finalScore.setOrigin(0.5);

            const restartText = scene.add.text(400, 400, 'Refresh page to play again!', {
                fontSize: '24px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 4
            });
            restartText.setOrigin(0.5);
        }
    </script>
</body>
</html>
