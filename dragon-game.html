<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dragon Flight Adventure</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/roughjs@4.5.2/bundled/rough.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(to bottom, #87CEEB, #E0F6FF);
            font-family: Arial, sans-serif;
        }
        #game-container {
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 400 },
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const game = new Phaser.Game(config);

        let dragon;
        let obstacles;
        let collectibles;
        let caveWalls;
        let topWallSegments = [];
        let bottomWallSegments = [];
        let cursors;
        let flapKey;
        let duckKey;
        let pauseKey;
        let isPaused = false;
        let health = 5;
        let score = 0;
        let level = 1;
        let healthText;
        let scoreText;
        let levelText;
        let gameOver = false;
        let gameStarted = false;
        let obstacleTimer;
        let collectibleTimer;
        let speed = 200;
        let roughCanvas;
        let rc;
        let caveWallHitCooldown = false;
        let instructions;

        // Helper function to create a canvas with Rough.js drawing
        function createRoughCanvas(width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            return {
                canvas: canvas,
                rc: rough.canvas(canvas)
            };
        }

        // Helper to convert hex color to RGB string
        function hexToRgb(hex) {
            const r = (hex >> 16) & 255;
            const g = (hex >> 8) & 255;
            const b = hex & 255;
            return `rgb(${r}, ${g}, ${b})`;
        }

        function preload() {
            // Load dragon sprite sheet (3 columns x 2 rows = 6 frames)
            this.load.spritesheet('dragon', 'dragon_sprites.png', {
                frameWidth: 512,
                frameHeight: 512
            });
        }

        function createWallTexture(isTop) {
            const wallCanvas = createRoughCanvas(800, 70);
            const wallRc = wallCanvas.rc;

            // Draw irregular rocky cave wall
            const wallPoints = [];
            for (let x = 0; x <= 800; x += 40) {
                const y = isTop ? (50 + Math.random() * 20) : (20 + Math.random() * 20);
                wallPoints.push([x, y]);
            }

            if (isTop) {
                wallPoints.unshift([0, 0]);
                wallPoints.push([800, 0]);
            } else {
                wallPoints.push([800, 70]);
                wallPoints.unshift([0, 70]);
            }

            wallRc.polygon(wallPoints, {
                fill: hexToRgb(0x4a4a4a),
                fillStyle: 'hachure',
                roughness: 2.5,
                strokeWidth: 3,
                stroke: hexToRgb(0x2a2a2a),
                hachureAngle: isTop ? 45 : -45,
                fillWeight: 3
            });

            // Add some rocky details
            for (let i = 0; i < 8; i++) {
                const x = i * 100 + 50;
                const y = isTop ? (40 + Math.random() * 15) : (30 + Math.random() * 15);
                wallRc.circle(x, y, 5 + Math.random() * 10, {
                    fill: hexToRgb(0x3a3a3a),
                    fillStyle: 'solid',
                    roughness: 3.0
                });
            }

            return wallCanvas.canvas;
        }

        function create() {
            // Create cave walls (top and bottom) for tunnel effect with scrolling
            caveWalls = this.add.group();

            // Create multiple segments for scrolling effect
            for (let i = 0; i < 3; i++) {
                // Top wall segment
                const topTextureName = `topWall_${i}`;
                this.textures.addCanvas(topTextureName, createWallTexture(true));
                const topWall = this.add.image(i * 800 + 400, 35, topTextureName);
                topWall.setOrigin(0.5, 0.5);
                this.physics.add.existing(topWall);
                topWall.body.setAllowGravity(false);
                topWall.body.setImmovable(true);
                topWall.body.setSize(800, 70);
                topWall.body.moves = false;
                topWallSegments.push(topWall);
                caveWalls.add(topWall);

                // Bottom wall segment
                const bottomTextureName = `bottomWall_${i}`;
                this.textures.addCanvas(bottomTextureName, createWallTexture(false));
                const bottomWall = this.add.image(i * 800 + 400, 565, bottomTextureName);
                bottomWall.setOrigin(0.5, 0.5);
                this.physics.add.existing(bottomWall);
                bottomWall.body.setAllowGravity(false);
                bottomWall.body.setImmovable(true);
                bottomWall.body.setSize(800, 70);
                bottomWall.body.moves = false;
                bottomWallSegments.push(bottomWall);
                caveWalls.add(bottomWall);
            }

            // Create dragon sprite with animation
            dragon = this.add.sprite(150, 300, 'dragon', 0);
            dragon.setScale(0.15); // Scale down from 512x512 to ~77px

            // Create flying animation from sprite sheet
            this.anims.create({
                key: 'fly',
                frames: this.anims.generateFrameNumbers('dragon', { start: 0, end: 5 }),
                frameRate: 10,
                repeat: -1
            });

            // Create idle animation (slower)
            this.anims.create({
                key: 'idle',
                frames: this.anims.generateFrameNumbers('dragon', { start: 0, end: 5 }),
                frameRate: 6,
                repeat: -1
            });

            // Start with idle animation
            dragon.play('idle');

            // Add physics to dragon sprite
            this.physics.add.existing(dragon);
            dragon.body.setSize(60, 50); // Adjusted for sprite
            dragon.body.setOffset(6, 12); // Center the hitbox on dragon body
            dragon.body.setBounce(0.2);

            // Create groups for obstacles and collectibles
            obstacles = this.physics.add.group();
            collectibles = this.physics.add.group();

            // Input
            cursors = this.input.keyboard.createCursorKeys();
            flapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
            duckKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.DOWN);
            pauseKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.P);

            // UI Text
            healthText = this.add.text(16, 16, 'Health: ❤️❤️❤️❤️❤️', {
                fontSize: '24px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 4
            });

            scoreText = this.add.text(16, 50, 'Score: 0', {
                fontSize: '24px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 4
            });

            levelText = this.add.text(16, 84, 'Level: 1', {
                fontSize: '24px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 4
            });

            const pauseText = this.add.text(750, 16, 'P = Pause', {
                fontSize: '20px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 3
            });
            pauseText.setOrigin(1, 0);

            // Spawn obstacles and collectibles (paused until game starts)
            obstacleTimer = this.time.addEvent({
                delay: 2500,
                callback: spawnObstacle,
                callbackScope: this,
                loop: true,
                paused: true
            });

            collectibleTimer = this.time.addEvent({
                delay: 3500,
                callback: spawnCollectible,
                callbackScope: this,
                loop: true,
                paused: true
            });

            // Collisions
            this.physics.add.overlap(dragon, obstacles, hitObstacle, null, this);
            this.physics.add.overlap(dragon, collectibles, collectItem, null, this);
            this.physics.add.overlap(dragon, caveWalls, hitCaveWall, null, this);

            // Instructions (stays until game starts)
            instructions = this.add.text(400, 300,
                'SPACE or UP = Flap Wings (Go Higher)\nDOWN = Duck (Go Lower)\n\nFly through the cave!\nAvoid walls and obstacles! Collect stars!\n\nPress SPACE to start!',
                {
                    fontSize: '20px',
                    fill: '#fff',
                    stroke: '#000',
                    strokeThickness: 4,
                    align: 'center'
                }
            );
            instructions.setOrigin(0.5);

            // Pause physics until game starts
            this.physics.pause();
        }

        function update() {
            // Wait for player to start the game
            if (!gameStarted && !gameOver) {
                if (Phaser.Input.Keyboard.JustDown(flapKey) || Phaser.Input.Keyboard.JustDown(cursors.up)) {
                    gameStarted = true;
                    this.physics.resume();
                    obstacleTimer.paused = false;
                    collectibleTimer.paused = false;
                    if (instructions) {
                        instructions.destroy();
                        instructions = null;
                    }
                }
                return;
            }

            if (gameOver) {
                return;
            }

            // Toggle pause
            if (Phaser.Input.Keyboard.JustDown(pauseKey)) {
                isPaused = !isPaused;
                if (isPaused) {
                    this.physics.pause();
                    obstacleTimer.paused = true;
                    collectibleTimer.paused = true;

                    const pauseMsg = this.add.text(400, 300, 'PAUSED\nPress P to resume', {
                        fontSize: '48px',
                        fill: '#fff',
                        stroke: '#000',
                        strokeThickness: 6,
                        align: 'center'
                    });
                    pauseMsg.setOrigin(0.5);
                    pauseMsg.setName('pauseMessage');
                } else {
                    this.physics.resume();
                    obstacleTimer.paused = false;
                    collectibleTimer.paused = false;

                    const pauseMsg = this.children.getByName('pauseMessage');
                    if (pauseMsg) pauseMsg.destroy();
                }
            }

            if (isPaused) {
                return;
            }

            // Flap wings (go up)
            if (Phaser.Input.Keyboard.JustDown(flapKey) || Phaser.Input.Keyboard.JustDown(cursors.up)) {
                dragon.body.setVelocityY(-300);

                // Switch to fast flapping animation
                if (dragon.anims.currentAnim.key !== 'fly') {
                    dragon.play('fly');
                }

                // Body tilt up
                this.tweens.add({
                    targets: dragon,
                    angle: -15,
                    duration: 100,
                    yoyo: true
                });
            }

            // Duck (go down faster)
            if (cursors.down.isDown || duckKey.isDown) {
                dragon.body.setVelocityY(400);

                // Slower animation when ducking
                if (dragon.anims.currentAnim.key !== 'idle') {
                    dragon.play('idle');
                }

                // Body tilt down
                dragon.angle = 15;
            } else {
                // Reset body angle
                if (dragon.angle > 0) {
                    dragon.angle = Math.max(0, dragon.angle - 1);
                } else if (dragon.angle < 0) {
                    dragon.angle = Math.min(0, dragon.angle + 1);
                }

                // Use idle animation when not pressing keys
                if (!Phaser.Input.Keyboard.JustDown(flapKey) && dragon.anims.currentAnim.key !== 'idle') {
                    dragon.play('idle');
                }
            }

            // Scroll cave walls for tunnel effect
            topWallSegments.forEach(wall => {
                wall.x -= speed * 0.016;
                // When wall goes off left side, move it to the right side
                if (wall.x < -400) {
                    wall.x += 800 * 3; // Move to end of the 3 segments
                }
            });

            bottomWallSegments.forEach(wall => {
                wall.x -= speed * 0.016;
                // When wall goes off left side, move it to the right side
                if (wall.x < -400) {
                    wall.x += 800 * 3; // Move to end of the 3 segments
                }
            });

            // Move obstacles and collectibles
            obstacles.children.entries.forEach(obstacle => {
                obstacle.x -= speed * 0.016;
                if (obstacle.x < -50) {
                    obstacle.destroy();
                    // Only award points if dragon is in valid position (accounting for hitbox)
                    // Dragon hitbox is 50px tall (±25 from center), walls end at 70 (top) and start at 530 (bottom)
                    const dragonTop = dragon.y - 25;
                    const dragonBottom = dragon.y + 25;
                    if (dragonTop > 70 && dragonBottom < 530) {
                        score += 10;
                        updateScore();
                    }
                }
            });

            collectibles.children.entries.forEach(collectible => {
                collectible.x -= speed * 0.016;
                if (collectible.x < -50) {
                    collectible.destroy();
                }
            });

            // Level progression
            if (score > 0 && score % 100 === 0 && score > (level - 1) * 100) {
                levelUp(this);
            }
        }

        function spawnObstacle() {
            if (gameOver) return;

            const type = Phaser.Math.Between(0, 1);
            const yPos = Phaser.Math.Between(100, 500);

            const obstacleCanvas = createRoughCanvas(40, 70);
            const obstacleRc = obstacleCanvas.rc;

            if (type === 0) {
                // Rock obstacle with sketchy detail (smaller for easier gameplay)
                obstacleRc.rectangle(5, 15, 30, 55, {
                    fill: hexToRgb(0x8B4513),
                    fillStyle: 'solid',
                    roughness: 2.5,
                    strokeWidth: 2,
                    stroke: hexToRgb(0x654321),
                    fillWeight: 2
                });

                obstacleRc.polygon([[5, 15], [20, -5], [35, 15]], {
                    fill: hexToRgb(0x654321),
                    fillStyle: 'hachure',
                    roughness: 2.5,
                    strokeWidth: 2,
                    stroke: hexToRgb(0x5a3a1a),
                    hachureAngle: 60
                });

                // Texture spots
                obstacleRc.circle(12, 30, 4, {
                    fill: hexToRgb(0x5a3a1a),
                    fillStyle: 'solid',
                    roughness: 2.0
                });
                obstacleRc.circle(23, 50, 5, {
                    fill: hexToRgb(0x5a3a1a),
                    fillStyle: 'solid',
                    roughness: 2.0
                });
            } else {
                // Stalactite/stalagmite with sketchy texture (smaller)
                obstacleRc.polygon([[5, 15], [20, 60], [35, 15]], {
                    fill: hexToRgb(0x696969),
                    fillStyle: 'solid',
                    roughness: 2.5,
                    strokeWidth: 2.5,
                    stroke: hexToRgb(0x505050),
                    fillWeight: 2
                });

                obstacleRc.polygon([[10, 22], [20, 52], [30, 22]], {
                    fill: hexToRgb(0x505050),
                    fillStyle: 'hachure',
                    roughness: 2.0,
                    hachureAngle: -60
                });
            }

            const textureName = `obstacle_${Date.now()}_${Math.random()}`;
            this.textures.addCanvas(textureName, obstacleCanvas.canvas);
            const obstacle = this.add.image(850, yPos, textureName);
            obstacle.setOrigin(0.5, 0.5);

            this.physics.add.existing(obstacle);
            obstacle.body.setSize(30, 45);
            obstacle.body.setAllowGravity(false);
            obstacle.body.setImmovable(true);
            obstacle.body.moves = false;

            obstacles.add(obstacle);
        }

        function spawnCollectible() {
            if (gameOver) return;

            const yPos = Phaser.Math.Between(100, 500);

            const starCanvas = createRoughCanvas(50, 50);
            const starRc = starCanvas.rc;

            // Draw a sketchy star
            const starPoints = [];
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                const x = 25 + Math.cos(angle) * 15;
                const y = 25 + Math.sin(angle) * 15;
                starPoints.push([x, y]);
            }

            starRc.polygon(starPoints, {
                fill: hexToRgb(0xFFD700),
                fillStyle: 'solid',
                roughness: 1.8,
                strokeWidth: 2.5,
                stroke: hexToRgb(0xdaa520),
                fillWeight: 2
            });

            // Add sketchy glow effect
            starRc.circle(25, 25, 18, {
                stroke: hexToRgb(0xFFFF00),
                strokeWidth: 3,
                roughness: 1.5,
                fill: 'none'
            });

            const textureName = `star_${Date.now()}_${Math.random()}`;
            this.textures.addCanvas(textureName, starCanvas.canvas);
            const collectible = this.add.image(850, yPos, textureName);
            collectible.setOrigin(0.5, 0.5);

            this.physics.add.existing(collectible);
            collectible.body.setCircle(15);
            collectible.body.setAllowGravity(false);
            collectible.body.moves = false;

            collectibles.add(collectible);

            // Sparkle animation
            this.tweens.add({
                targets: collectible,
                scaleX: 1.3,
                scaleY: 1.3,
                duration: 500,
                yoyo: true,
                repeat: -1
            });
        }

        function hitObstacle(dragon, obstacle) {
            obstacle.destroy();
            health--;
            updateHealth();

            // Flash red
            this.cameras.main.flash(200, 255, 0, 0);

            if (health <= 0) {
                endGame(this);
            }
        }

        function hitCaveWall(dragon, wall) {
            // Don't destroy wall (it's permanent)
            // Use cooldown to prevent rapid repeated damage
            if (caveWallHitCooldown) return;

            caveWallHitCooldown = true;
            health--;
            updateHealth();

            // Flash red
            this.cameras.main.flash(200, 255, 0, 0);

            // Camera shake for impact
            this.cameras.main.shake(200, 0.01);

            // Reset cooldown after half a second
            this.time.delayedCall(500, () => {
                caveWallHitCooldown = false;
            });

            if (health <= 0) {
                endGame(this);
            }
        }

        function collectItem(dragon, collectible) {
            collectible.destroy();
            health = Math.min(5, health + 1);
            score += 20;
            updateHealth();
            updateScore();

            // Flash green
            this.cameras.main.flash(200, 0, 255, 0);
        }

        function updateHealth() {
            const hearts = '❤️'.repeat(health);
            healthText.setText('Health: ' + hearts);
        }

        function updateScore() {
            scoreText.setText('Score: ' + score);
        }

        function levelUp(scene) {
            level++;
            levelText.setText('Level: ' + level);
            speed += 30;

            // Show level up message
            const levelUpText = scene.add.text(400, 300, 'LEVEL UP!', {
                fontSize: '48px',
                fill: '#FFD700',
                stroke: '#000',
                strokeThickness: 6
            });
            levelUpText.setOrigin(0.5);

            scene.tweens.add({
                targets: levelUpText,
                scaleX: 1.5,
                scaleY: 1.5,
                alpha: 0,
                duration: 1500,
                onComplete: () => levelUpText.destroy()
            });

            // Spawn obstacles faster
            obstacleTimer.delay = Math.max(800, 2000 - (level * 200));
        }

        function endGame(scene) {
            gameOver = true;

            scene.physics.pause();

            // Change dragon to defeated colors - red tint
            dragon.setTint(0x8B0000);
            dragon.stop(); // Stop animation

            const gameOverText = scene.add.text(400, 250, 'GAME OVER!', {
                fontSize: '64px',
                fill: '#ff0000',
                stroke: '#000',
                strokeThickness: 8
            });
            gameOverText.setOrigin(0.5);

            const finalScore = scene.add.text(400, 330, `Final Score: ${score}`, {
                fontSize: '32px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 4
            });
            finalScore.setOrigin(0.5);

            const restartText = scene.add.text(400, 400, 'Refresh page to play again!', {
                fontSize: '24px',
                fill: '#fff',
                stroke: '#000',
                strokeThickness: 4
            });
            restartText.setOrigin(0.5);
        }
    </script>
</body>
</html>
